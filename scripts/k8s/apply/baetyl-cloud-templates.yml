apiVersion: v1
data:
  baetyl-core-app.yml: |-
    name: "{{.CoreAppName}}"
    namespace: "{{.Namespace}}"
    selector: "baetyl-node-name={{.NodeName}}"
    labels:
      baetyl-cloud-system: "true"
    type: "container"
    system: true
    services:
      - name: "baetyl-core"
        image: "{{GetProperty "baetyl-image"}}"
        replica: 1
        args:
          - "core"
        volumeMounts:
          - name: "core-conf"
            mountPath: "/etc/baetyl"
            readOnly: true
          - name: "node-cert"
            mountPath: "/var/lib/baetyl/node"
          - name: "core-store-path"
            mountPath: "/var/lib/baetyl/store"
          - name: "object-download-path"
            mountPath: "/var/lib/baetyl/object"
          - name: "host-root-path"
            mountPath: "/var/lib/baetyl/host"
        ports:
          - containerPort: 80
            hostPort: 30050
            protocol: "TCP"
    volumes:
      - name: "core-conf"
        config:
          name: "{{.CoreConfName}}"
          version: "{{.CoreConfVersion}}"
      - name: "node-cert"
        secret:
          name: "{{.NodeCertName}}"
          version: "{{.NodeCertVersion}}"
      - name: "core-store-path"
        hostPath:
          path: "/var/lib/baetyl/store"
      - name: "object-download-path"
        hostPath:
          path: "/var/lib/baetyl/object"
      - name: "host-root-path"
        hostPath:
          path: "/var/lib/baetyl/host"
  baetyl-core-conf.yml: |-
    name: "{{.CoreConfName}}"
    namespace: "{{.Namespace}}"
    system: true
    labels:
      baetyl-app-name: "{{.CoreAppName}}"
      baetyl-node-name: "{{.NodeName}}"
      baetyl-cloud-system: "true"
    data:
      conf.yml: |-
        node:
          ca: var/lib/baetyl/node/ca.pem
          key: var/lib/baetyl/node/client.key
          cert: var/lib/baetyl/node/client.pem
        httplink:
          address: "{{GetProperty "sync-server-address"}}"
          insecureSkipVerify: true
        logger:
          level: debug
  baetyl-function-app.yml: |-
    name: "{{.FunctionAppName}}"
    namespace: "{{.Namespace}}"
    selector: "baetyl-node-name={{.NodeName}}"
    labels:
      baetyl-cloud-system: "true"
    type: "container"
    system: true
    services:
      - name: "baetyl-function"
        image: "{{GetProperty "baetyl-function-image"}}"
        replica: 1
        volumeMounts:
          - name: "func-conf"
            mountPath: "/etc/baetyl"
            readOnly: true
        ports:
          - containerPort: 80
            protocol: "TCP"
    volumes:
      - name: "func-conf"
        config:
          name: "{{.FunctionConfName}}"
          version: "{{.FunctionConfVersion}}"
  baetyl-function-conf.yml: |-
    name: "{{.FunctionConfName}}"
    namespace: "{{.Namespace}}"
    system: true
    labels:
      baetyl-app-name: "{{.FunctionAppName}}"
      baetyl-node-name: "{{.NodeName}}"
      baetyl-cloud-system: "true"
    data:
      conf.yml: |-
        logger:
          level: debug
  baetyl-init-deployment.yml: |-
    ---
    apiVersion: v1
    kind: Namespace
    metadata:
      name: {{.EdgeSystemNamespace}}

    ---
    apiVersion: v1
    kind: Namespace
    metadata:
      name: {{.EdgeNamespace}}

    ---
    apiVersion: v1
    kind: ServiceAccount
    metadata:
      name: baetyl-edge-system-service-account
      namespace: {{.EdgeSystemNamespace}}

    ---
    # elevation of authority
    apiVersion: rbac.authorization.k8s.io/v1beta1
    kind: ClusterRoleBinding
    metadata:
      name: baetyl-edge-system-rbac
    subjects:
      - kind: ServiceAccount
        name: baetyl-edge-system-service-account
        namespace: {{.EdgeSystemNamespace}}
    roleRef:
      kind: ClusterRole
      name: cluster-admin
      apiGroup: rbac.authorization.k8s.io

    ---
    kind: StorageClass
    apiVersion: storage.k8s.io/v1
    metadata:
      name: local-storage
    provisioner: kubernetes.io/no-provisioner
    volumeBindingMode: WaitForFirstConsumer

    {{- if .NodeCertPem}}

    ---
    apiVersion: v1
    kind: Secret
    metadata:
      name: {{.NodeCertName}}
      namespace: {{.EdgeSystemNamespace}}
    type: Opaque
    data:
      client.pem: '{{.NodeCertPem}}'
      client.key: '{{.NodeCertKey}}'
      ca.pem: '{{.NodeCertCa}}'
    {{- end}}

    ---
    # baetyl-init configmap
    apiVersion: v1
    kind: ConfigMap
    metadata:
      name: baetyl-init-config
      namespace: {{.EdgeSystemNamespace}}
    data:
      conf.yml: |-
        node:
          ca: var/lib/baetyl/node/ca.pem
          key: var/lib/baetyl/node/client.key
          cert: var/lib/baetyl/node/client.pem
        httplink:
          address: {{GetProperty "sync-server-address"}}
          insecureSkipVerify: true
        logger:
          level: debug

    ---
    # baetyl-init deployment
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: baetyl-init
      namespace: {{.EdgeSystemNamespace}}
      labels:
        baetyl-app-name: baetyl-init
        baetyl-service-name: baetyl-init
    spec:
      selector:
        matchLabels:
          baetyl-service-name: baetyl-init
      replicas: 1
      template:
        metadata:
          labels:
            baetyl-app-name: baetyl-init
            baetyl-service-name: baetyl-init
        spec:
          nodeName: {{.KubeNodeName}}
          serviceAccountName: baetyl-edge-system-service-account
          containers:
            - name: baetyl-init
              image: {{GetProperty "baetyl-image"}}
              imagePullPolicy: IfNotPresent
              args:
                - init
              env:
                - name: KUBE_NODE_NAME
                  valueFrom:
                    fieldRef:
                      fieldPath: spec.nodeName
              volumeMounts:
                - name: init-conf
                  mountPath: /etc/baetyl
                - name: core-store-path
                  mountPath: /var/lib/baetyl/store
                - name: object-download-path
                  mountPath: /var/lib/baetyl/object
                - name: host-root-path
                  mountPath: /var/lib/baetyl/host
                {{- if .NodeCertPem}}
                - name: node-cert
                  mountPath: var/lib/baetyl/node
                {{- end}}
          volumes:
            - name: init-conf
              configMap:
                name: baetyl-init-config
            - name: core-store-path
              hostPath:
                path: /var/lib/baetyl/store
            - name: object-download-path
              hostPath:
                path: /var/lib/baetyl/object
            - name: host-root-path
              hostPath:
                path: /var/lib/baetyl/host
            {{- if .NodeCertPem}}
            - name: node-cert
              secret:
                secretName: {{.NodeCertName}}
            {{- end}}
  kube-api-metrics.yml: |-
    kind: ClusterRole
    apiVersion: rbac.authorization.k8s.io/v1
    metadata:
      name: system:aggregated-metrics-reader
      labels:
        rbac.authorization.k8s.io/aggregate-to-view: "true"
        rbac.authorization.k8s.io/aggregate-to-edit: "true"
        rbac.authorization.k8s.io/aggregate-to-admin: "true"
    rules:
      - apiGroups: ["metrics.k8s.io"]
        resources: ["pods", "nodes"]
        verbs: ["get", "list", "watch"]
    ---
    apiVersion: rbac.authorization.k8s.io/v1beta1
    kind: ClusterRoleBinding
    metadata:
      name: metrics-server:system:auth-delegator
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: ClusterRole
      name: system:auth-delegator
    subjects:
      - kind: ServiceAccount
        name: metrics-server
        namespace: kube-system
    ---
    apiVersion: rbac.authorization.k8s.io/v1beta1
    kind: RoleBinding
    metadata:
      name: metrics-server-auth-reader
      namespace: kube-system
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: Role
      name: extension-apiserver-authentication-reader
    subjects:
      - kind: ServiceAccount
        name: metrics-server
        namespace: kube-system
    ---
    apiVersion: apiregistration.k8s.io/v1beta1
    kind: APIService
    metadata:
      name: v1beta1.metrics.k8s.io
    spec:
      service:
        name: metrics-server
        namespace: kube-system
      group: metrics.k8s.io
      version: v1beta1
      insecureSkipTLSVerify: true
      groupPriorityMinimum: 100
      versionPriority: 100
    ---
    apiVersion: v1
    kind: ServiceAccount
    metadata:
      name: metrics-server
      namespace: kube-system
    ---
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: metrics-server
      namespace: kube-system
      labels:
        k8s-app: metrics-server
    spec:
      selector:
        matchLabels:
          k8s-app: metrics-server
      template:
        metadata:
          name: metrics-server
          labels:
            k8s-app: metrics-server
        spec:
          serviceAccountName: metrics-server
          volumes:
            # mount in tmp so we can safely use from-scratch images and/or read-only containers
            - name: tmp-dir
              emptyDir: {}
          containers:
            - name: metrics-server
              image: 'rancher/metrics-server:v0.3.6'
              imagePullPolicy: IfNotPresent
              command:
                - /metrics-server
                - --kubelet-insecure-tls
                - --kubelet-preferred-address-types=InternalDNS,InternalIP,ExternalDNS,ExternalIP,Hostname
              volumeMounts:
                - name: tmp-dir
                  mountPath: /tmp
    ---
    apiVersion: v1
    kind: Service
    metadata:
      name: metrics-server
      namespace: kube-system
      labels:
        kubernetes.io/name: "Metrics-server"
        kubernetes.io/cluster-service: "true"
    spec:
      selector:
        k8s-app: metrics-server
      ports:
        - port: 443
          protocol: TCP
          targetPort: 443
    ---
    apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRole
    metadata:
      name: system:metrics-server
    rules:
      - apiGroups:
          - ""
        resources:
          - pods
          - nodes
          - nodes/stats
          - namespaces
        verbs:
          - get
          - list
          - watch
    ---
    apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRoleBinding
    metadata:
      name: system:metrics-server
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: ClusterRole
      name: system:metrics-server
    subjects:
      - kind: ServiceAccount
        name: metrics-server
        namespace: kube-system
  kube-init-setup.sh: |-
    #!/bin/sh

    set -e

    OS=$(uname)
    TOKEN="{{.Token}}"
    ADDR="{{GetProperty "init-server-address"}}"
    DEPLOYYML="{{.DeploymentYml}}"
    SUDO=sudo

    exec_cmd_nobail() {
      echo "+ $2 bash -c \"$1\""
      $2 bash -c "$1"
    }

    print_status() {
      echo "## $1"
    }

    url_safe_check() {
      if ! curl -Ifs $1 >/dev/null; then
        print_status "ERROR: $1 is invalid or Unreachable!"
      fi
    }

    check_cmd() {
      command -v $1 | awk '{print}'
    }

    get_dependencies() {
      PRE_INSTALL_PKGS=""

      if [ ! -x "$(check_cmd curl)" ]; then
        PRE_INSTALL_PKGS="${PRE_INSTALL_PKGS} curl"
      fi

      if [ "X${PRE_INSTALL_PKGS}" != "X" ]; then
        case "$OS" in
        Linux)
          LSB_DIST=$(. /etc/os-release && echo "$ID" | tr '[:upper:]' '[:lower:]')
          case "$LSB_DIST" in
          ubuntu | debian | raspbian)
            exec_cmd_nobail "apt update && apt install --no-install-recommends -y ${PRE_INSTALL_PKGS} >/dev/null 2>&1" $SUDO
            ;;
          centos)
            exec_cmd_nobail "yum install ${PRE_INSTALL_PKGS} -y >/dev/null 2>&1" $SUDO
            ;;
          *)
            print_status "Your OS is not supported!"
            ;;
          esac
          ;;
        Darwin)
          print_status "You must install ${PRE_INSTALL_PKGS} to continue..."
          exit 0
          ;;
        *)
          print_status "Your OS: $OS is not supported!"
          exit 0
          ;;
        esac
      fi
    }

    install_docker() {
      TARGET_URL=http://get.daocloud.io/docker/
      url_safe_check ${TARGET_URL}
      exec_cmd_nobail "curl -sSL ${TARGET_URL} | $SUDO sh"

      if [[ ! -x "$(command -v docker)" ]]; then
          print_status "Install docker failed! Check the installing process for help..."
      fi

      if [[ ! -x "$(command -v systemctl)" ]]; then
          LSB_DIST=$(. /etc/os-release && echo "$ID" | tr '[:upper:]' '[:lower:]')
          case "$LSB_DIST" in
          ubuntu | debian | raspbian)
              exec_cmd_nobail "apt update && apt install --no-install-recommends -y systemd  >/dev/null 2>&1" $SUDO
              ;;
          centos)
              exec_cmd_nobail "yum install systemd -y  >/dev/null 2>&1" $SUDO
              ;;
          *)
              print_status "Your OS: $OS is not supported!"
              exit 0
              ;;
          esac
      fi

      exec_cmd_nobail "systemctl enable docker" $SUDO
      exec_cmd_nobail "systemctl start docker" $SUDO
    }

    check_and_get_kube() {
      if [ ! -x "$(check_cmd kubectl)" ]; then
        read -p "K8S/K3S is not installed yet, do you want us to install K3S for you? Yes/No (default: Yes):" IS_INSTALL_K3S
        if [ "$IS_INSTALL_K3S" = "n" -o "$IS_INSTALL_K3S" = "N" -o "$IS_INSTALL_K3S" = "no" -o "$IS_INSTALL_K3S" = "NO" ]; then
          echo "K3S is needed to run ${NAME}, this script will exit now..."
          exit 0
        fi

        if [ $OS = "Linux" ]; then
            read -p "K3S could run with containerd/docker, which do you want us to install for you? containerd for Yes, docker for No (default: Yes):" IS_INSTALL_CONTAINERD
            if [ "$IS_INSTALL_CONTAINERD" = "n" -o "$IS_INSTALL_CONTAINERD" = "N" -o "$IS_INSTALL_CONTAINERD" = "no" -o "$IS_INSTALL_CONTAINERD" = "NO" ]; then
              if [ ! -x "$(check_cmd docker)" ]; then
                install_docker
              else
                print_status "Docker already installed"
              fi
              export INSTALL_K3S_EXEC="--docker --write-kubeconfig ~/.kube/config --write-kubeconfig-mode 666"
            else
              export INSTALL_K3S_EXEC="--write-kubeconfig ~/.kube/config --write-kubeconfig-mode 666"
            fi

          exec_cmd_nobail "curl -sfL https://docs.rancher.cn/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn sh -"

          if [ ! -x "$(check_cmd kubectl)" ]; then
            print_status "Install k3s failed! Check the installing process for help..."
            exit 0
          fi

          exec_cmd_nobail "systemctl enable k3s" $SUDO
          exec_cmd_nobail "systemctl start k3s" $SUDO

        elif [ $OS = "Darwin" ]; then
          exec_cmd_nobail "curl -sfL https://get.k3s.io | sh -"
        else
          print_status "We are not supporting your system, this script will exit now..."
          exit 0
        fi
      fi
      exec_cmd_nobail "kubectl version" $SUDO
    }

    get_kube_master() {
      $SUDO kubectl get no | awk '/master/ || /controlplane/' | awk '{print $1}'
    }

    check_baetyl_namespace() {
      $SUDO kubectl get ns | grep 'baetyl-edge-system' | awk '{print $1}'
    }

    check_and_install_baetyl() {
      BAETYL_NAMESPACE=$(check_baetyl_namespace)
      if [ ! -z "$BAETYL_NAMESPACE" ]; then
        read -p "The namespace 'baetyl-edge-system' already exists, do you want to clean up old applications by deleting this namespace? Yes/No (default: Yes):" IS_DELETE_NS
        if [ "$IS_DELETE_NS" = "n" -o "$IS_DELETE_NS" = "N" -o "$IS_DELETE_NS" = "no" -o "$IS_DELETE_NS" = "NO" ]; then
          echo "baetyl-init is not install, this script will exit now..."
          exit 0
        else
          rbac=$($SUDO kubectl get clusterrolebinding | grep baetyl-edge-system-rbac | awk '{print $1}')
          if [ -n "$rbac" ]; then
            exec_cmd_nobail "kubectl delete clusterrolebinding baetyl-edge-system-rbac" $SUDO
          fi
          exec_cmd_nobail "kubectl delete namespace baetyl-edge-system" $SUDO
        fi
      fi

      KUBE_MASTER_NODE_NAME=$(get_kube_master)
      if [ ! -z "$KUBE_MASTER_NODE_NAME" ]; then
        exec_cmd_nobail "mkdir -p -m 666 /var/lib/baetyl/host" $SUDO
        exec_cmd_nobail "mkdir -p -m 666 /var/lib/baetyl/object" $SUDO
        exec_cmd_nobail "mkdir -p -m 666 /var/lib/baetyl/store" $SUDO
        exec_cmd_nobail "mkdir -p -m 666 /var/lib/baetyl/log" $SUDO
        kube_apply "$ADDR/v1/init/$DEPLOYYML?token=$TOKEN&node=$KUBE_MASTER_NODE_NAME"
      else
        print_status "Can not get kubernetes master or controlplane node, this script will exit now..."
      fi
    }

    kube_apply() {
      TempFile=$(mktemp temp.XXXXXX)
      exec_cmd_nobail "curl -skfL \"$1\" >$TempFile" $SUDO
      exec_cmd_nobail "kubectl apply -f $TempFile" $SUDO
      exec_cmd_nobail "rm -f $TempFile 2>/dev/null" $SUDO
    }

    check_and_get_metrics() {
      METRICS=$(check_kube_res metrics-server)
      if [ -z "$METRICS" ]; then
        kube_apply "$ADDR/v1/init/kube-api-metrics.yml?token=$TOKEN"
      fi
    }

    check_kube_res() {
      $SUDO kubectl get deployments -A | grep $1 | awk '{print $2}'
    }

    check_and_get_storage() {
      PROVISIONER=$(check_kube_res local-path-provisioner)
      if [ -z "$PROVISIONER" ]; then
        kube_apply "$ADDR/v1/init/kube-local-path-storage.yml?token=$TOKEN"
      fi
    }

    check_user() {
      if [ $(id -u) -eq 0 ]; then
        SUDO=
      fi
    }

    uninstall() {
      exec_cmd_nobail "kubectl delete ns baetyl-edge baetyl-edge-system" $SUDO
    }

    install() {
      check_user
      get_dependencies
      check_and_get_kube
      check_and_get_metrics
      check_and_get_storage
      check_and_install_baetyl
    }

    case C"$1" in
    C)
      install
      ;;
    Cuninstall)
      uninstall
      ;;
    Cinstall)
      install
      ;;
    C*)
      Usage: setup.sh { install | uninstall }
      ;;
    esac

    echo "Done!"
    exit 0
  kube-local-path-storage.yml: |-
    apiVersion: v1
    kind: Namespace
    metadata:
      name: local-path-storage
    ---
    apiVersion: v1
    kind: ServiceAccount
    metadata:
      name: local-path-provisioner-service-account
      namespace: local-path-storage
    ---
    apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRole
    metadata:
      name: local-path-provisioner-role
    rules:
      - apiGroups: [""]
        resources: ["nodes", "persistentvolumeclaims"]
        verbs: ["get", "list", "watch"]
      - apiGroups: [""]
        resources: ["endpoints", "persistentvolumes", "pods"]
        verbs: ["*"]
      - apiGroups: [""]
        resources: ["events"]
        verbs: ["create", "patch"]
      - apiGroups: ["storage.k8s.io"]
        resources: ["storageclasses"]
        verbs: ["get", "list", "watch"]
    ---
    apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRoleBinding
    metadata:
      name: local-path-provisioner-bind
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: ClusterRole
      name: local-path-provisioner-role
    subjects:
      - kind: ServiceAccount
        name: local-path-provisioner-service-account
        namespace: local-path-storage
    ---
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: local-path-provisioner
      namespace: local-path-storage
    spec:
      replicas: 1
      selector:
        matchLabels:
          app: local-path-provisioner
      template:
        metadata:
          labels:
            app: local-path-provisioner
        spec:
          serviceAccountName: local-path-provisioner-service-account
          containers:
            - name: local-path-provisioner
              image: rancher/local-path-provisioner:v0.0.12
              imagePullPolicy: IfNotPresent
              command:
                - local-path-provisioner
                - --debug
                - start
                - --config
                - /etc/config/config.json
              volumeMounts:
                - name: config-volume
                  mountPath: /etc/config/
              env:
                - name: POD_NAMESPACE
                  valueFrom:
                    fieldRef:
                      fieldPath: metadata.namespace
          volumes:
            - name: config-volume
              configMap:
                name: local-path-config
    ---
    apiVersion: storage.k8s.io/v1
    kind: StorageClass
    metadata:
      name: local-path
    provisioner: rancher.io/local-path
    volumeBindingMode: WaitForFirstConsumer
    reclaimPolicy: Delete
    ---
    kind: ConfigMap
    apiVersion: v1
    metadata:
      name: local-path-config
      namespace: local-path-storage
    data:
      config.json: |-
        {
                "nodePathMap":[
                {
                        "node":"DEFAULT_PATH_FOR_NON_LISTED_NODES",
                        "paths":["/opt/local-path-provisioner"]
                }]
        }
kind: ConfigMap
metadata:
  name: baetyl-cloud-templates
  namespace: default
